<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TakePips - Trading Signals Dashboard</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#6366f1">
    <meta name="description" content="Dashboard para visualizar sinais de trading em tempo real">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TakePips">
    
    <!-- Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icon-192.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icon-96.png">
    <link rel="shortcut icon" href="/icon-192.png">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="/icon-192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icon-152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-card-hover: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --border-color: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #0f172a 50%, #1e293b 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            padding: 40px 20px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border-radius: 24px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
            animation: pulse-glow 4s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% {
                opacity: 0.5;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        .logo-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(99, 102, 241, 0.4);
            position: relative;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-8px);
            }
        }

        .logo-icon svg {
            width: 40px;
            height: 40px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .logo-icon svg path:first-of-type {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: draw-line 1.5s ease-in-out forwards;
        }

        .logo-icon svg path:nth-of-type(2) {
            opacity: 0;
            animation: fade-in 0.5s ease-in-out 1s forwards;
        }

        .logo-icon svg circle {
            opacity: 0;
            transform: scale(0);
            animation: pop-in 0.3s ease-out forwards;
        }

        .logo-icon svg circle:nth-of-type(1) { animation-delay: 0.2s; }
        .logo-icon svg circle:nth-of-type(2) { animation-delay: 0.3s; }
        .logo-icon svg circle:nth-of-type(3) { animation-delay: 0.4s; }
        .logo-icon svg circle:nth-of-type(4) { animation-delay: 0.5s; }
        .logo-icon svg circle:nth-of-type(5) { animation-delay: 0.6s; }
        .logo-icon svg circle:nth-of-type(6) { animation-delay: 0.7s; }

        @keyframes draw-line {
            to {
                stroke-dashoffset: 0;
            }
        }

        @keyframes fade-in {
            to {
                opacity: 0.15;
            }
        }

        @keyframes pop-in {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
            font-weight: 500;
            margin-top: 10px;
            position: relative;
            z-index: 1;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(30, 41, 59, 0.8) 100%);
            padding: 20px 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            width: 100%;
            height: 120px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-dark));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            border-color: var(--primary-color);
            box-shadow: 0 12px 24px -4px rgba(99, 102, 241, 0.3);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--primary-color);
            text-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px -2px rgba(99, 102, 241, 0.4);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px -2px rgba(99, 102, 241, 0.6);
        }

        button span {
            position: relative;
            z-index: 1;
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .error {
            text-align: center;
            padding: 20px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger-color);
            border-radius: 8px;
            color: var(--danger-color);
            margin-bottom: 20px;
        }

        .signals-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        /* Responsividade para mobile */
        @media (max-width: 768px) {
            .stats-bar {
                grid-template-columns: 1fr; /* 1 card por linha no mobile */
            }
            
            .stat-card {
                height: 100px; /* Altura menor no mobile */
                padding: 15px 20px;
            }
            
            .stat-value {
                font-size: 1.5rem;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .stats-bar {
                grid-template-columns: repeat(2, 1fr); /* 2 cards por linha em tablets */
            }
        }

        @media (min-width: 1200px) {
            .signals-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .stats-bar {
                grid-template-columns: repeat(5, 1fr); /* 5 cards por linha em desktop */
            }
        }

        .signal-card {
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(30, 41, 59, 0.9) 100%);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 24px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px -2px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            position: relative;
            overflow: hidden;
        }

        .signal-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s ease;
        }

        .signal-card:hover::after {
            left: 100%;
        }

        .signal-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--border-color);
        }

        .signal-card.buy::before {
            background: var(--success-color);
        }

        .signal-card.sell::before {
            background: var(--danger-color);
        }

        /* Cards com Stop Loss atingido - fundo vermelho */
        .signal-card.status-stop_loss {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(239, 68, 68, 0.05) 100%);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .signal-card.status-stop_loss::before {
            background: var(--danger-color);
            height: 6px;
        }

        /* Cards com Take atingido (TAKE1, TAKE2, TAKE3) - fundo verde */
        .signal-card.status-take1,
        .signal-card.status-take2,
        .signal-card.status-take3 {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(16, 185, 129, 0.05) 100%);
            border-color: rgba(16, 185, 129, 0.5);
        }

        .signal-card.status-take1::before,
        .signal-card.status-take2::before,
        .signal-card.status-take3::before {
            background: var(--success-color);
            height: 6px;
        }

        /* Cards pendentes mant√™m o estilo padr√£o */
        .signal-card.status-pending {
            background: var(--bg-card);
            border-color: var(--border-color);
        }

        /* Cards encerrados - fundo cinza/desativado */
        .signal-card.status-encerrado {
            background: linear-gradient(135deg, rgba(100, 116, 139, 0.15) 0%, rgba(100, 116, 139, 0.05) 100%);
            border-color: rgba(100, 116, 139, 0.5);
            opacity: 0.7;
        }

        .signal-card.status-encerrado::before {
            background: #64748b;
            height: 6px;
        }

        .signal-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: var(--primary-color);
            box-shadow: 0 16px 32px -4px rgba(99, 102, 241, 0.4), 0 0 0 1px rgba(99, 102, 241, 0.2) inset;
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .signal-type {
            font-size: 0.75rem;
            font-weight: 700;
            padding: 4px 12px;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .signal-type.buy {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success-color);
        }

        .signal-type.sell {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger-color);
        }

        .signal-status {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 6px;
            font-weight: 600;
        }

        .signal-status.pending {
            background: rgba(100, 116, 139, 0.2);
            color: var(--text-secondary);
        }

        .signal-status.stop_loss {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger-color);
        }

        .signal-status.take1,
        .signal-status.take2,
        .signal-status.take3 {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success-color);
        }

        .signal-symbol {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .signal-prices {
            display: grid;
            gap: 10px;
        }

        .price-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .price-row:hover {
            background: rgba(99, 102, 241, 0.05);
            margin: 0 -12px;
            padding-left: 12px;
            padding-right: 12px;
            border-radius: 8px;
        }

        .price-row:last-child {
            border-bottom: none;
        }

        .price-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .price-value {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
        }

        .price-value.hit {
            color: var(--success-color);
            font-weight: 800;
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        .hit-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .hit-info strong {
            color: var(--primary-color);
        }

        .signal-time {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            opacity: 0.5;
        }

        /* Estilos para abas */
        .tabs-container {
            display: flex;
            gap: 10px;
            margin-bottom: 24px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0;
        }

        .tab-button {
            background: transparent;
            border: none;
            padding: 12px 24px;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            bottom: -2px;
        }

        .tab-button:hover {
            color: var(--text-primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: rgba(99, 102, 241, 0.15);
        }

        .tab-button span {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        @media (max-width: 768px) {
            .tabs-container {
                gap: 5px;
            }
            
            .tab-button {
                padding: 10px 16px;
                font-size: 0.85rem;
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .loading .signal-card {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-container">
                <div class="logo-icon">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <!-- Linha principal do gr√°fico (tend√™ncia ascendente) -->
                        <path d="M3 18L7 14L11 12L15 10L19 6L21 4" 
                              stroke="white" 
                              stroke-width="2.5" 
                              stroke-linecap="round" 
                              stroke-linejoin="round"
                              fill="none"/>
                        <!-- √Årea preenchida sob o gr√°fico -->
                        <path d="M3 18L7 14L11 12L15 10L19 6L21 4L21 20L3 20Z" 
                              stroke="none" 
                              fill="white" 
                              opacity="0.15"/>
                        <!-- Pontos nos v√©rtices -->
                        <circle cx="3" cy="18" r="2" fill="white"/>
                        <circle cx="7" cy="14" r="2" fill="white"/>
                        <circle cx="11" cy="12" r="2" fill="white"/>
                        <circle cx="15" cy="10" r="2" fill="white"/>
                        <circle cx="19" cy="6" r="2" fill="white"/>
                        <circle cx="21" cy="4" r="2.5" fill="white" opacity="0.9"/>
                        <!-- Moldura -->
                        <rect x="2" y="2" width="20" height="20" rx="2" stroke="white" stroke-width="1.5" fill="none" opacity="0.4"/>
                    </svg>
                </div>
                <h1>TakePips</h1>
            </div>
            <p class="subtitle">Trading Signals Dashboard</p>
        </header>

        <div class="stats-bar" id="statsBar">
            <div class="stat-card">
                <div class="stat-label">Total de Sinais</div>
                <div class="stat-value" id="totalSignals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Pendentes</div>
                <div class="stat-value" id="pendingSignals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Takes Atingidos</div>
                <div class="stat-value" id="totalTakesHit" style="color: var(--success-color);">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Stop Loss</div>
                <div class="stat-value" id="stopLossSignals" style="color: var(--danger-color);">0</div>
            </div>
            <div class="stat-card" style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.1) 100%); border-color: rgba(99, 102, 241, 0.5);">
                <div class="stat-label">Pontos Alcan√ßados (30 dias)</div>
                <div class="stat-value" id="totalPoints" style="color: var(--primary-color); font-size: 1.8rem;">0</div>
            </div>
        </div>

        <div class="controls">
            <button onclick="loadSignals()" id="refreshBtn">
                <span>üîÑ Atualizar</span>
            </button>
            <button onclick="autoRefresh()" id="autoRefreshBtn">
                <span>‚è±Ô∏è Auto-refresh: OFF</span>
            </button>
            <button onclick="requestNotificationPermission()" id="notificationsBtn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                <span>üîî Ativar Notifica√ß√µes</span>
            </button>
        </div>

        <div id="errorContainer"></div>

        <!-- Abas para filtrar sinais -->
        <div class="tabs-container">
            <button class="tab-button active" onclick="switchTab('active')" id="tabActive">
                <span>üîÑ Em Andamento</span>
            </button>
            <button class="tab-button" onclick="switchTab('closed')" id="tabClosed">
                <span>‚úÖ Encerrados</span>
            </button>
        </div>

        <div id="signalsContainer" class="signals-grid">
            <div class="loading">Carregando sinais...</div>
        </div>
    </div>

    <script>
        const API_URL = window.location.origin + '/api/signals/list';
        let autoRefreshInterval = null;
        let isAutoRefreshOn = false;
        let currentTab = 'active'; // 'active' ou 'closed'
        let allSignals = []; // Armazenar todos os sinais carregados

        async function loadSignals() {
            const container = document.getElementById('signalsContainer');
            const errorContainer = document.getElementById('errorContainer');
            const refreshBtn = document.getElementById('refreshBtn');
            
            // N√£o desabilitar bot√£o nem mostrar loading durante auto-refresh para n√£o piscar a tela
            const isAutoRefreshing = isAutoRefreshOn;
            
            if (!isAutoRefreshing) {
                refreshBtn.disabled = true;
                container.innerHTML = '<div class="loading">Carregando sinais...</div>';
            }
            errorContainer.innerHTML = '';

            try {
                // Adicionar timestamp para evitar cache
                const response = await fetch(API_URL + '?t=' + Date.now(), {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error?.message || 'Erro ao carregar sinais');
                }

                allSignals = data.data || []; // Armazenar todos os sinais
                updateStats(allSignals); // Atualizar estat√≠sticas com todos os sinais
                displaySignals(); // Exibir sinais filtrados pela aba ativa
            } catch (error) {
                if (!isAutoRefreshing) {
                    errorContainer.innerHTML = `
                        <div class="error">
                            <strong>Erro:</strong> ${error.message}
                        </div>
                    `;
                    container.innerHTML = '';
                } else {
                    console.error('Erro durante auto-refresh:', error);
                }
            } finally {
                if (!isAutoRefreshing) {
                    refreshBtn.disabled = false;
                }
            }
        }

        // Exibir sinais filtrados pela aba ativa
        function displaySignals() {
            const container = document.getElementById('signalsContainer');
            const isAutoRefreshing = isAutoRefreshOn;
            
            // Filtrar sinais baseado na aba ativa
            let filteredSignals = [];
            
            if (currentTab === 'active') {
                // Sinais em andamento: todos exceto ENCERRADO e TAKE3
                filteredSignals = allSignals.filter(signal => {
                    const status = (signal.status || 'PENDING').toUpperCase();
                    return status !== 'ENCERRADO' && status !== 'TAKE3';
                });
            } else {
                // Sinais encerrados: ENCERRADO ou TAKE3
                filteredSignals = allSignals.filter(signal => {
                    const status = (signal.status || 'PENDING').toUpperCase();
                    return status === 'ENCERRADO' || status === 'TAKE3';
                });
            }

            if (filteredSignals.length === 0) {
                if (!isAutoRefreshing || container.innerHTML.includes('loading')) {
                    const emptyMessage = currentTab === 'active' 
                        ? 'Nenhum sinal em andamento. Os sinais aparecer√£o aqui quando forem enviados pelo EA.'
                        : 'Nenhum sinal encerrado ainda.';
                    
                    container.innerHTML = `
                        <div class="empty-state">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                            <h3>Nenhum sinal encontrado</h3>
                            <p>${emptyMessage}</p>
                        </div>
                    `;
                }
            } else {
                // Sempre atualizar, mesmo durante auto-refresh
                container.innerHTML = filteredSignals.map(signal => createSignalCard(signal)).join('');
            }
        }

        // Alternar entre abas
        function switchTab(tab) {
            currentTab = tab;
            
            // Atualizar estado visual das abas
            document.getElementById('tabActive').classList.toggle('active', tab === 'active');
            document.getElementById('tabClosed').classList.toggle('active', tab === 'closed');
            
            // Exibir sinais filtrados
            displaySignals();
        }

        function createSignalCard(signal) {
            const type = signal.type.toLowerCase();
            // Normalizar status para garantir que funcione com qualquer formato
            const rawStatus = signal.status || 'PENDING';
            // Converter 'STOP_LOSS' para 'stop_loss' corretamente
            const status = rawStatus.toLowerCase();
            const statusText = getStatusText(rawStatus);
            
            // Adicionar classe de status para aplicar cores de fundo
            // Ex: 'stop_loss', 'take1', 'take2', 'take3', 'pending'
            const statusClass = `status-${status}`;
            
            const formatPrice = (price) => {
                if (typeof price !== 'number' || isNaN(price)) return '-';
                // Sempre mostrar apenas 2 casas decimais
                return price.toFixed(2);
            };

            const formatDate = (dateString) => {
                if (!dateString) return '-';
                const date = new Date(dateString);
                return date.toLocaleString('pt-BR', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            const hitInfo = getHitInfo(signal);

            return `
                <div class="signal-card ${type} ${statusClass}">
                    <div class="signal-header">
                        <span class="signal-type ${type}">${signal.type}</span>
                        <span class="signal-status ${status}">${statusText}</span>
                    </div>
                    
                    <div class="signal-symbol">${signal.symbol}</div>
                    
                    <div class="signal-prices">
                        <div class="price-row">
                            <span class="price-label">Entry:</span>
                            <span class="price-value">${formatPrice(signal.entry)}</span>
                        </div>
                        <div class="price-row">
                            <span class="price-label">Stop Loss:</span>
                            <span class="price-value ${signal.stopHitPrice ? 'hit' : ''}">${formatPrice(signal.stopLoss)}</span>
                        </div>
                        <div class="price-row">
                            <span class="price-label">Take 1:</span>
                            <span class="price-value ${signal.take1HitPrice ? 'hit' : ''}">${formatPrice(signal.take1)}</span>
                        </div>
                        <div class="price-row">
                            <span class="price-label">Take 2:</span>
                            <span class="price-value ${signal.take2HitPrice ? 'hit' : ''}">${formatPrice(signal.take2)}</span>
                        </div>
                        <div class="price-row">
                            <span class="price-label">Take 3:</span>
                            <span class="price-value ${signal.take3HitPrice ? 'hit' : ''}">${formatPrice(signal.take3)}</span>
                        </div>
                    </div>

                    ${hitInfo ? `<div class="hit-info">${hitInfo}</div>` : ''}

                    <div class="signal-time">
                        Criado: ${formatDate(signal.createdAt)}
                    </div>
                </div>
            `;
        }

        function getStatusText(status) {
            if (!status) return 'Pendente';
            
            const statusMap = {
                'PENDING': 'Pendente',
                'pending': 'Pendente',
                'STOP_LOSS': 'Stop Loss',
                'stop_loss': 'Stop Loss',
                'STOPLOSS': 'Stop Loss',
                'TAKE1': 'Take 1',
                'take1': 'Take 1',
                'TAKE2': 'Take 2',
                'take2': 'Take 2',
                'TAKE3': 'Take 3',
                'take3': 'Take 3',
                'ENCERRADO': 'Encerrado',
                'encerrado': 'Encerrado'
            };
            
            return statusMap[status.toUpperCase()] || statusMap[status] || status;
        }

        function getHitInfo(signal) {
            const hits = [];
            
            if (signal.stopHitPrice) {
                hits.push(`<strong>Stop:</strong> ${signal.stopHitPrice.toFixed(5)} em ${formatDate(signal.stopHitAt)}`);
            }
            if (signal.take1HitPrice) {
                hits.push(`<strong>Take1:</strong> ${signal.take1HitPrice.toFixed(5)} em ${formatDate(signal.take1HitAt)}`);
            }
            if (signal.take2HitPrice) {
                hits.push(`<strong>Take2:</strong> ${signal.take2HitPrice.toFixed(5)} em ${formatDate(signal.take2HitAt)}`);
            }
            if (signal.take3HitPrice) {
                hits.push(`<strong>Take3:</strong> ${signal.take3HitPrice.toFixed(5)} em ${formatDate(signal.take3HitAt)}`);
            }

            return hits.length > 0 ? hits.join('<br>') : null;
        }

        function formatDate(dateString) {
            if (!dateString) return '-';
            const date = new Date(dateString);
            return date.toLocaleString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function updateStats(signals) {
            const total = signals.length;
            // Normalizar compara√ß√µes para aceitar diferentes formatos
            // Excluir sinais encerrados da contagem de pendentes
            const pending = signals.filter(s => {
                const status = (s.status || 'PENDING').toUpperCase();
                return status === 'PENDING' && status !== 'ENCERRADO';
            }).length;
            
            const stopLoss = signals.filter(s => {
                const status = (s.status || '').toUpperCase();
                return status === 'STOP_LOSS' || status === 'STOPLOSS';
            }).length;

            // Filtrar sinais dos √∫ltimos 30 dias para c√°lculo de pontos
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const signalsLast30Days = signals.filter(signal => {
                const signalDate = new Date(signal.createdAt || signal.time);
                return signalDate >= thirtyDaysAgo;
            });

            // Calcular takes atingidos e pontos baseados na diferen√ßa de pre√ßo
            // Usar TODOS os sinais para contar takes (estat√≠stica geral)
            let totalTakesHit = 0;
            
            // Usar apenas sinais dos √∫ltimos 30 dias para calcular pontos
            let totalPoints = 0;

            // Contar takes de todos os sinais
            signals.forEach(signal => {
                if (signal.take1HitPrice) totalTakesHit++;
                if (signal.take2HitPrice) totalTakesHit++;
                if (signal.take3HitPrice) totalTakesHit++;
            });

            // Calcular pontos apenas dos √∫ltimos 30 dias
            signalsLast30Days.forEach(signal => {
                // Trabalhar com a precis√£o original do banco (3 casas decimais)
                // Normalizar para 3 casas decimais antes de calcular para evitar erros de ponto flutuante
                const entry = parseFloat(parseFloat(signal.entry || 0).toFixed(3));
                const type = signal.type.toUpperCase();
                
                // Calcular pontos do Take 1 (se atingido)
                if (signal.take1HitPrice) {
                    const take1Price = parseFloat(parseFloat(signal.take1HitPrice).toFixed(3));
                    let priceDiff = 0;
                    if (type === 'BUY') {
                        priceDiff = take1Price - entry;
                    } else {
                        priceDiff = entry - take1Price;
                    }
                    // Normalizar diferen√ßa para 3 casas decimais
                    priceDiff = parseFloat(priceDiff.toFixed(3));
                    // Dividir por 10 e normalizar para 3 casas antes de somar
                    const points = parseFloat((priceDiff / 10).toFixed(3));
                    totalPoints += points;
                }
                
                // Calcular pontos do Take 2 (se atingido)
                if (signal.take2HitPrice) {
                    const take2Price = parseFloat(parseFloat(signal.take2HitPrice).toFixed(3));
                    let priceDiff = 0;
                    if (type === 'BUY') {
                        priceDiff = take2Price - entry;
                    } else {
                        priceDiff = entry - take2Price;
                    }
                    priceDiff = parseFloat(priceDiff.toFixed(3));
                    const points = parseFloat((priceDiff / 10).toFixed(3));
                    totalPoints += points;
                }
                
                // Calcular pontos do Take 3 (se atingido)
                if (signal.take3HitPrice) {
                    const take3Price = parseFloat(parseFloat(signal.take3HitPrice).toFixed(3));
                    let priceDiff = 0;
                    if (type === 'BUY') {
                        priceDiff = take3Price - entry;
                    } else {
                        priceDiff = entry - take3Price;
                    }
                    priceDiff = parseFloat(priceDiff.toFixed(3));
                    const points = parseFloat((priceDiff / 10).toFixed(3));
                    totalPoints += points;
                }
                
                // Subtrair pontos se stop loss foi atingido
                if (signal.stopHitPrice) {
                    const stopPrice = parseFloat(parseFloat(signal.stopHitPrice).toFixed(3));
                    let priceDiff = 0;
                    if (type === 'BUY') {
                        priceDiff = entry - stopPrice;
                    } else {
                        priceDiff = stopPrice - entry;
                    }
                    priceDiff = parseFloat(priceDiff.toFixed(3));
                    const points = parseFloat((priceDiff / 10).toFixed(3));
                    totalPoints -= points;
                }
            });

            document.getElementById('totalSignals').textContent = total;
            document.getElementById('pendingSignals').textContent = pending;
            document.getElementById('totalTakesHit').textContent = totalTakesHit;
            document.getElementById('stopLossSignals').textContent = stopLoss;
            
            // Atualizar pontos com cor baseada no saldo e formatar n√∫mero
            const pointsElement = document.getElementById('totalPoints');
            // Exibir com 3 casas decimais (mesma precis√£o do banco)
            // Normalizar para 3 casas decimais para evitar problemas de ponto flutuante
            const normalizedPoints = parseFloat(totalPoints.toFixed(3));
            pointsElement.textContent = normalizedPoints.toFixed(3);
            
            if (totalPoints > 0) {
                pointsElement.style.color = 'var(--success-color)';
            } else if (totalPoints < 0) {
                pointsElement.style.color = 'var(--danger-color)';
            } else {
                pointsElement.style.color = 'var(--text-secondary)';
            }
        }

        function autoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            
            if (isAutoRefreshOn) {
                clearInterval(autoRefreshInterval);
                isAutoRefreshOn = false;
                btn.innerHTML = '<span>‚è±Ô∏è Auto-refresh: OFF</span>';
            } else {
                // Intervalo otimizado: 15 segundos (reduz carga no servidor)
                const refreshInterval = 15000;
                autoRefreshInterval = setInterval(loadSignals, refreshInterval);
                isAutoRefreshOn = true;
                btn.innerHTML = `<span>‚è±Ô∏è Auto-refresh: ON (${refreshInterval / 1000}s)</span>`;
            }
        }

        // Carregar sinais ao iniciar
        loadSignals();
        
        // N√£o iniciar auto-refresh automaticamente - deixar usu√°rio escolher
        // Isso reduz a carga no servidor e economiza recursos
        
        // Atualizar bot√£o de notifica√ß√µes ap√≥s carregar
        setTimeout(() => {
            updateNotificationButton();
        }, 1000);

        // ========== WEB PUSH NOTIFICATIONS ==========
        
        let notificationPermission = 'default';
        let pushSubscription = null;

        // Registrar Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js');
                    console.log('‚úÖ Service Worker registrado:', registration.scope);
                    
                    // Aguardar um pouco antes de solicitar permiss√£o
                    setTimeout(() => {
                        requestNotificationPermission();
                    }, 2000);
                } catch (error) {
                    console.error('‚ùå Erro ao registrar Service Worker:', error);
                }
            });
        }

        // Atualizar bot√£o de notifica√ß√µes
        function updateNotificationButton() {
            const btn = document.getElementById('notificationsBtn');
            if (!btn) return;
            
            const support = checkPushNotificationSupport();
            if (!support.supported) {
                btn.innerHTML = '<span>‚ö†Ô∏è N√£o Suportado</span>';
                btn.style.background = 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)';
                btn.disabled = true;
                btn.title = support.reason + ' ' + support.suggestion;
                return;
            }
            
            const permission = Notification.permission;
            if (permission === 'granted') {
                btn.innerHTML = '<span>‚úÖ Notifica√ß√µes Ativas</span>';
                btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                btn.disabled = true;
            } else if (permission === 'denied') {
                btn.innerHTML = '<span>‚ö†Ô∏è Notifica√ß√µes Bloqueadas</span>';
                btn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            } else {
                btn.innerHTML = '<span>üîî Ativar Notifica√ß√µes</span>';
                btn.style.background = 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)';
            }
        }

        // Verificar suporte completo a notifica√ß√µes push
        function checkPushNotificationSupport() {
            // Verificar se √© Safari
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            // Verificar suporte b√°sico
            if (!('Notification' in window)) {
                return {
                    supported: false,
                    reason: 'Seu navegador n√£o suporta notifica√ß√µes b√°sicas.',
                    suggestion: 'Use Chrome, Firefox, Edge ou Safari 16+ no macOS.'
                };
            }
            
            // Verificar Service Worker
            if (!('serviceWorker' in navigator)) {
                return {
                    supported: false,
                    reason: 'Service Worker n√£o est√° dispon√≠vel.',
                    suggestion: 'Use um navegador moderno que suporte Service Workers.'
                };
            }
            
            // Verificar Push Manager
            if (!('PushManager' in window)) {
                return {
                    supported: false,
                    reason: 'Push Manager n√£o est√° dispon√≠vel.',
                    suggestion: isSafari && isIOS 
                        ? 'Safari no iOS n√£o suporta notifica√ß√µes push. Use Safari no macOS ou outro navegador.'
                        : 'Use um navegador moderno com suporte completo a Web Push.'
                };
            }
            
            // Safari no macOS: verificar vers√£o m√≠nima (16.0+)
            if (isSafari && !isIOS) {
                const safariVersion = navigator.userAgent.match(/Version\/(\d+)/);
                if (safariVersion && parseInt(safariVersion[1]) < 16) {
                    return {
                        supported: false,
                        reason: 'Safari muito antigo.',
                        suggestion: 'Atualize o Safari para vers√£o 16.0 ou superior, ou use outro navegador.'
                    };
                }
            }
            
            // Safari no iOS n√£o suporta Web Push nativamente
            if (isSafari && isIOS) {
                return {
                    supported: false,
                    reason: 'Safari no iOS n√£o suporta notifica√ß√µes push web.',
                    suggestion: 'Use Safari no macOS (vers√£o 16.0+), Chrome, Firefox ou Edge.'
                };
            }
            
            return {
                supported: true,
                browser: isSafari ? 'Safari' : 'Outro'
            };
        }

        // Solicitar permiss√£o de notifica√ß√£o
        async function requestNotificationPermission() {
            const support = checkPushNotificationSupport();
            
            if (!support.supported) {
                alert(`‚ùå ${support.reason}\n\nüí° ${support.suggestion}`);
                return;
            }

            notificationPermission = Notification.permission;

            if (notificationPermission === 'granted') {
                console.log('‚úÖ Permiss√£o de notifica√ß√£o j√° concedida');
                await subscribeToPush();
                updateNotificationButton();
            } else if (notificationPermission === 'default') {
                // Solicitar permiss√£o quando usu√°rio clicar no bot√£o
                console.log('üì¢ Aguardando a√ß√£o do usu√°rio para solicitar permiss√£o...');
                updateNotificationButton();
            } else {
                // Permiss√£o negada
                updateNotificationButton();
                console.log('‚ö†Ô∏è Permiss√£o de notifica√ß√£o negada');
            }
        }

        // Inscrever para receber push notifications
        async function subscribeToPush() {
            const support = checkPushNotificationSupport();
            
            if (!support.supported) {
                console.error('‚ùå Push notifications n√£o suportadas:', support.reason);
                return;
            }
            
            if (!('serviceWorker' in navigator)) {
                console.log('‚ùå Service Worker n√£o dispon√≠vel');
                return;
            }

            try {
                const registration = await navigator.serviceWorker.ready;
                
                // Obter chave p√∫blica VAPID
                const publicKey = await getVapidPublicKey();
                if (!publicKey) {
                    console.error('‚ùå N√£o foi poss√≠vel obter VAPID public key');
                    return;
                }
                
                // Obter subscription
                const subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: urlBase64ToUint8Array(publicKey)
                });

                pushSubscription = subscription;
                console.log('‚úÖ Inscrito para push notifications:', subscription);

                // Enviar subscription para o servidor
                await sendSubscriptionToServer(subscription);
            } catch (error) {
                console.error('‚ùå Erro ao inscrever para push:', error);
                
                if (error.name === 'NotAllowedError') {
                    console.log('‚ö†Ô∏è Permiss√£o de notifica√ß√£o negada pelo usu√°rio');
                }
            }
        }

        // Converter chave VAPID de base64 URL para Uint8Array
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');

            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);

            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // Obter chave p√∫blica VAPID do servidor
        let cachedVapidPublicKey = null;
        
        async function getVapidPublicKey() {
            if (cachedVapidPublicKey) {
                return cachedVapidPublicKey;
            }

            try {
                const response = await fetch('/api/push/vapid-public-key');
                const data = await response.json();
                
                if (data.success && data.data.publicKey) {
                    cachedVapidPublicKey = data.data.publicKey;
                    return cachedVapidPublicKey;
                } else {
                    console.error('‚ùå Erro ao obter VAPID public key:', data);
                    return null;
                }
            } catch (error) {
                console.error('‚ùå Erro ao buscar VAPID public key:', error);
                return null;
            }
        }

        // Enviar subscription para o servidor
        async function sendSubscriptionToServer(subscription) {
            try {
                const response = await fetch('/api/push/subscribe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        subscription: {
                            endpoint: subscription.endpoint,
                            keys: {
                                p256dh: arrayBufferToBase64(subscription.getKey('p256dh')),
                                auth: arrayBufferToBase64(subscription.getKey('auth'))
                            }
                        }
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ Subscription salva no servidor');
                } else {
                    console.error('‚ùå Erro ao salvar subscription:', await response.text());
                }
            } catch (error) {
                console.error('‚ùå Erro ao enviar subscription:', error);
            }
        }

        // Converter ArrayBuffer para Base64
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // Fun√ß√£o para solicitar permiss√£o manualmente (pode ser chamada por um bot√£o)
        window.requestNotificationPermission = async () => {
            const support = checkPushNotificationSupport();
            
            if (!support.supported) {
                alert(`‚ùå ${support.reason}\n\nüí° ${support.suggestion}`);
                return;
            }

            // Se j√° tem permiss√£o, apenas inscrever
            if (Notification.permission === 'granted') {
                await subscribeToPush();
                updateNotificationButton();
                return;
            }

            // Se foi negada, mostrar instru√ß√µes
            if (Notification.permission === 'denied') {
                alert('‚ö†Ô∏è Notifica√ß√µes foram bloqueadas. Para ativar:\n\n1. Clique no √≠cone de cadeado na barra de endere√ßos\n2. V√° em "Configura√ß√µes do site"\n3. Altere "Notifica√ß√µes" para "Permitir"\n4. Recarregue a p√°gina');
                updateNotificationButton();
                return;
            }

            // Solicitar permiss√£o
            const permission = await Notification.requestPermission();
            
            if (permission === 'granted') {
                console.log('‚úÖ Permiss√£o concedida!');
                await subscribeToPush();
                updateNotificationButton();
                alert('‚úÖ Notifica√ß√µes ativadas! Voc√™ receber√° alertas quando seus sinais atingirem Take ou Stop Loss.');
            } else {
                console.log('‚ùå Permiss√£o negada');
                updateNotificationButton();
            }
        };
        
        // Fun√ß√£o de diagn√≥stico (para debug)
        window.diagnoseNotifications = async () => {
            console.log('üîç Diagn√≥stico de Notifica√ß√µes:\n');
            
            // 1. Suporte do navegador
            console.log('1. Suporte do navegador:');
            console.log('   - Notifications:', 'Notification' in window ? '‚úÖ' : '‚ùå');
            console.log('   - Service Worker:', 'serviceWorker' in navigator ? '‚úÖ' : '‚ùå');
            console.log('   - Push Manager:', 'PushManager' in window ? '‚úÖ' : '‚ùå');
            
            // 2. Permiss√£o
            console.log('\n2. Permiss√£o:');
            console.log('   Status:', Notification.permission);
            
            // 3. Service Worker
            console.log('\n3. Service Worker:');
            try {
                const reg = await navigator.serviceWorker.getRegistration();
                if (reg) {
                    console.log('   ‚úÖ Registrado:', reg.scope);
                    console.log('   Estado:', reg.active ? 'Ativo' : reg.installing ? 'Instalando' : 'Esperando');
                } else {
                    console.log('   ‚ùå N√£o registrado');
                }
            } catch (e) {
                console.log('   ‚ùå Erro:', e.message);
            }
            
            // 4. Subscription
            console.log('\n4. Subscription:');
            try {
                const reg = await navigator.serviceWorker.ready;
                const sub = await reg.pushManager.getSubscription();
                if (sub) {
                    console.log('   ‚úÖ Inscrito');
                    console.log('   Endpoint:', sub.endpoint.substring(0, 50) + '...');
                    console.log('   Keys:', sub.getKey('p256dh') ? '‚úÖ p256dh' : '‚ùå', sub.getKey('auth') ? '‚úÖ auth' : '‚ùå');
                } else {
                    console.log('   ‚ùå N√£o inscrito');
                }
            } catch (e) {
                console.log('   ‚ùå Erro:', e.message);
            }
            
            // 5. VAPID Key
            console.log('\n5. VAPID Public Key:');
            try {
                const response = await fetch('/api/push/vapid-public-key');
                const data = await response.json();
                if (data.success) {
                    console.log('   ‚úÖ Configurada:', data.data.publicKey.substring(0, 30) + '...');
                } else {
                    console.log('   ‚ùå N√£o configurada ou erro:', data);
                }
            } catch (e) {
                console.log('   ‚ùå Erro ao buscar:', e.message);
            }
            
            console.log('\nüí° Para ver mais detalhes, verifique: TROUBLESHOOTING_NOTIFICACOES.md');
        };

        console.log('üì± Sistema de notifica√ß√µes push inicializado');
    </script>
</body>
</html>

